---
title: "[Algorithm, C++] 백준 2872: 우리집엔 도서관이 있어"
date: 2021-03-30T22:38:21+09:00
slug: ""
description: ""
keywords: []
draft: true
tags: [Algorithm, C++]
math: false
toc: false
---
# 문제

상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다. 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.

오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다. 상근이는 책을 알파벳 순서대로 정렬하려고 한다. 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다. 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.

책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다. 1은 사전 순으로 가장 앞서는 책이다. 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다. 예를 들어, 책이 3권있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다. 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다. 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.

현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.

# 예제

```cpp
3
3
2
1
```

# 출력

```cpp
2
```

# 풀이

그리디 알고리즘 분류 문제이다.

내가 사용한 풀이는 다음과 같다.

"입력 받은 배열을 뒤에서 부터 순회하면서  입력받은 N값과 배열에 든 수를 비교해서 같은 수를 찾으면 N을 하나씩 감소시켜 갯수를 센다. 그 갯수를 N에서 빼서 출력한다."

입력받은 수들을 정렬하는데 있어서 움직일 필요가 있는 수가 있고 움직일 필요가 없는 수도 있다.

뒤에서 부터 입력 받은 N과 같은 수는 움직일 필요가 없는 수 이다.

### 예시

```cpp
5
4
3
2
5
1
```

다음과 같이 입력이 주어지면, 4와 5는 움직일 필요가 없다. 움직일 필요가 있는 수는 1, 2, 3이다.

3을 위로, 2를 위로, 1을 위로 하게 되면 정렬이 완료된다.

따라서 움직일 필요가 없는 수의 갯수인 2개를 전체 배열에서 뺀 3이 출력되야하는 수이다.

# 코드

```cpp
#include <iostream>
using namespace std;
int stack[300001];

int main()
{
	int N;
	int i;
	int j;
	int count;
	int last;

	cin >> N;
	i = 0;
	j = N - 1;
	last = N;
	count = 0;
	while (i < N)
		cin >> stack[i++];
	while (j >= 0)
	{
		if (stack[j] == last)
		{
			count++;
			last--;
		}
		j--;
	}
	cout << N - count;
}
```
