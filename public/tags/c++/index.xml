<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on kkeujeogblog</title>
    <link>https://parkjoungwan.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on kkeujeogblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Sun, 25 Apr 2021 14:21:09 +0900</lastBuildDate><atom:link href="https://parkjoungwan.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 15787: 기차가 어둠을 헤치고 은하수를</title>
      <link>https://parkjoungwan.github.io/blog/15787/</link>
      <pubDate>Sun, 25 Apr 2021 14:21:09 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/15787/</guid>
      <description>문제 N개의 기차가 어둠을 헤치고 은하수를 건너려고 한다.
기차는 20개의 일렬로 된 좌석이 있고, 한 개의 좌석에는 한 명의 사람이 탈 수 있다.
기차의 번호를 1번부터 N번으로 매길 때, 어떠한 기차에 대하여 M개의 명령이 주어진다.
명령의 종류는 4가지로 다음과 같다.
 1 i x : i번째 기차에(1 ≤ i ≤ N) x번째 좌석에(1 ≤ x ≤ 20) 사람을 태워라. 이미 사람이 타있다면 , 아무런 행동을 하지 않는다. 2 i x : i번째 기차에 x번째 좌석에 앉은 사람은 하차한다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1068: 트리</title>
      <link>https://parkjoungwan.github.io/blog/1068/</link>
      <pubDate>Tue, 20 Apr 2021 22:39:53 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/1068/</guid>
      <description>문제 트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.
트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.
예를 들어, 다음과 같은 트리가 있다고 하자.
현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.
이제 리프 노드의 개수는 1개이다.
예제 5 -1 0 0 1 1 2  출력 2  풀이 bfs로 트리를 탐색하는 문제였다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 11437: LCA</title>
      <link>https://parkjoungwan.github.io/blog/11437/</link>
      <pubDate>Tue, 20 Apr 2021 22:38:53 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/11437/</guid>
      <description>문제 N(2 ≤ N ≤ 50,000)개의 정점으로 이루어진 트리가 주어진다. 트리의 각 정점은 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다.
두 노드의 쌍 M(1 ≤ M ≤ 10,000)개가 주어졌을 때, 두 노드의 가장 가까운 공통 조상이 몇 번인지 출력한다.
예제 15 1 2 1 3 2 4 3 7 6 2 3 8 4 9 2 5 5 11 7 13 10 4 11 15 12 5 14 7 6 6 11 10 9 2 6 7 6 8 13 8 15  출력 2 4 2 1 3 1  풀이 공통조상을 찾는 문제이다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 4256: 트리</title>
      <link>https://parkjoungwan.github.io/blog/4256/</link>
      <pubDate>Tue, 13 Apr 2021 21:04:34 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/4256/</guid>
      <description>문제 이진 트리는 매우 중요한 기본 자료 구조이다. 아래 그림은 루트 노드가 유일한 이진 트리이다. 모든 노드는 최대 2개의 자식 노드를 가질 수 있으며, 왼쪽 자식이 순서가 먼저이다. 노드 n개로 이루어진 이진 트리를 BT라고 하자. BT의 노드는 1부터 n까지 유일한 번호가 매겨져 있다.
아래 그림에 나와있는 BT의 루트는 3번 노드이다. 1번 노드는 오른쪽 자식만 가지고 있고, 4와 7은 왼쪽 자식만 가지고 있다. 3과 6은 왼쪽과 오른쪽 자식을 모두 가지고 있다. 나머지 노드는 모두 자식이 없으며, 이러한 노드는 리프 노드라고 부른다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1074: Z</title>
      <link>https://parkjoungwan.github.io/blog/1074/</link>
      <pubDate>Tue, 13 Apr 2021 20:24:56 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/1074/</guid>
      <description>문제 한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.
만약, N &amp;gt; 1이 라서 왼쪽 위에 있는 칸이 하나가 아니라면, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.
다음 예는 22 × 22 크기의 배열을 방문한 순서이다.
N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.
다음은 N=3일 때의 예이다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1981: 배열의 이동</title>
      <link>https://parkjoungwan.github.io/blog/nojam1981/</link>
      <pubDate>Sun, 11 Apr 2021 17:35:25 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1981/</guid>
      <description>문제 n×n짜리의 배열이 하나 있다. 이 배열의 (1, 1)에서 (n, n)까지 이동하려고 한다. 이동할 때는 상, 하, 좌, 우의 네 인접한 칸으로만 이동할 수 있다.
이와 같이 이동하다 보면, 배열에서 몇 개의 수를 거쳐서 이동하게 된다. 이동하기 위해 거쳐 간 수들 중 최댓값과 최솟값의 차이가 가장 작아지는 경우를 구하는 프로그램을 작성하시오.
예제 5 1 1 3 6 8 1 2 2 5 5 4 4 0 3 3 8 0 2 3 4 4 3 0 2 1  출력 2  풀이 이 문제도 이분탐색 문제다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2022: 사다리</title>
      <link>https://parkjoungwan.github.io/blog/nojam2022/</link>
      <pubDate>Wed, 07 Apr 2021 17:38:24 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2022/</guid>
      <description>문제 아래의 그림과 같이 높은 빌딩 사이를 따라 좁은 길이 나있다. 두 개의 사다리가 있는데 길이가 x인 사다리는 오른쪽 빌딩의 아래를 받침대로 하여 왼쪽 빌딩에 기대져 있고 길이가 y인 사다리는 왼쪽 빌딩의 아래를 받침대로 하여 오른쪽 빌딩에 기대져 있다. 그리고 두 사다리는 땅에서부터 정확하게 c인 지점에서 서로 교차한다. 그렇다면 두 빌딩은 얼마나 떨어져 있는 걸까?
예제 30 40 10  출력 26.033  풀이 &amp;ldquo;주어진 값들로 수식을 세워야 한다.&amp;rdquo;
찾아야 하는 아래쪽, 두 집 사이의 거리 w</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1477: 휴게소 세우기</title>
      <link>https://parkjoungwan.github.io/blog/nojam1477/</link>
      <pubDate>Wed, 07 Apr 2021 16:48:53 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1477/</guid>
      <description>문제 다솜이는 유료 고속도로를 가지고 있다. 다솜이는 현재 고속도로에 휴게소를 N개 가지고 있는데, 휴게소의 위치는 고속도로의 시작으로부터 얼만큼 떨어져 있는지로 주어진다. 다솜이는 지금 휴게소를 M개 더 세우려고 한다.
다솜이는 이미 휴게소가 있는 곳에 휴게소를 또 세울 수 없고, 고속도로의 끝에도 휴게소를 세울 수 없다. 휴게소는 정수 위치에만 세울 수 있다.
다솜이는 이 고속도로를 이용할 때, 모든 휴게소를 방문한다. 다솜이는 휴게소를 M개 더 지어서 휴게소가 없는 구간의 길이의 최댓값을 최소로 하려고 한다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 11812: K진 트리</title>
      <link>https://parkjoungwan.github.io/blog/nojam11812/</link>
      <pubDate>Fri, 02 Apr 2021 16:29:50 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam11812/</guid>
      <description>문제 각 노드가 자식을 최대 K개 가질 수 있는 트리를 K진 트리라고 한다. 총 N개의 노드로 이루어져 있는 K진 트리가 주어진다.
트리는 &amp;ldquo;적은 에너지&amp;rdquo; 방법을 이용해서 만든다. &amp;ldquo;적은 에너지&amp;rdquo; 방법이란, 이전 깊이를 모두 채운 경우에만, 새로운 깊이를 만드는 것이고, 이 새로운 깊이의 노드는 가장 왼쪽부터 차례대로 추가 한다.
아래 그림은 노드 9개로 이루어져 있는 3진 트리이다.
노드의 개수 N과 K가 주어졌을 때, 두 노드 x와 y 사이의 거리를 구하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 9202: Boggle</title>
      <link>https://parkjoungwan.github.io/blog/nojam9202/</link>
      <pubDate>Thu, 01 Apr 2021 21:58:54 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam9202/</guid>
      <description>문제 상근이는 보드 게임 &amp;ldquo;Boggle&amp;quot;을 엄청나게 좋아한다. Boggle은 글자가 쓰여 있는 주사위로 이루어진 4×4 크기의 그리드에서 최대한 많은 단어를 찾는 게임이다.
상근이는 한 번도 부인을 Boggle로 이겨본 적이 없다. 이렇게 질 때마다 상근이는 쓰레기 버리기, 설거지와 같은 일을 해야 한다. 이제 상근이는 프로그램을 작성해서 부인을 이겨보려고 한다.
Boggle에서 단어는 인접한 글자(가로, 세로, 대각선)를 이용해서 만들 수 있다. 하지만, 한 주사위는 단어에 한 번만 사용할 수 있다. 단어는 게임 사전에 등재되어 있는 단어만 올바른 단어이다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2858: 경비행기</title>
      <link>https://parkjoungwan.github.io/blog/nojam2858/</link>
      <pubDate>Wed, 31 Mar 2021 18:24:59 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2858/</guid>
      <description>문제 경비행기 독수리호가 출발지 S에서 목적지 T로 가능한 빠른 속도로 안전하게 이동하고자 한다. 이때, 경비행기의 연료통의 크기를 정하는 것이 중요한 문제가 된다. 큰 연료통을 장착하면 중간에 내려서 급유를 받는 횟수가 적은 장점이 있지만 연료통의 무게로 인하여 속도가 느려지고, 안정성에도 문제가 있을 수 있다. 한편 작은 연료통을 장착하면 비행기의 속도가 빨라지는 장점이 있지만 중간에 내려서 급유를 받아야 하는 횟수가 많아지는 단점이 있다. 문제는 중간에 내려서 급유를 받는 횟수가 k이하 일 때 연료통의 최소용량을 구하는 것이다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2872: 우리집엔 도서관이 있어</title>
      <link>https://parkjoungwan.github.io/blog/nojam2872/</link>
      <pubDate>Tue, 30 Mar 2021 22:38:21 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2872/</guid>
      <description>문제 상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다. 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.
오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다. 상근이는 책을 알파벳 순서대로 정렬하려고 한다. 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다. 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.
책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2110 : 공유기 설치</title>
      <link>https://parkjoungwan.github.io/blog/nojam2110/</link>
      <pubDate>Wed, 24 Mar 2021 20:20:11 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2110/</guid>
      <description>문제 도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, &amp;hellip;, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.
도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1325 : 효율적인 해킹</title>
      <link>https://parkjoungwan.github.io/blog/nojam1325/</link>
      <pubDate>Wed, 24 Mar 2021 20:10:46 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1325/</guid>
      <description>문제 해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.
이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.
이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1300 : k번째 수</title>
      <link>https://parkjoungwan.github.io/blog/nojam1300/</link>
      <pubDate>Wed, 24 Mar 2021 17:58:20 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1300/</guid>
      <description>문제 세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.
배열 A와 B의 인덱스는 1부터 시작한다.
예제 3 7  출력 6  풀이 문제에서 나오는 배열을 만들었다가는 메모리 초과로 실패를 겪게 된다. 이진탐색을 사용해야 하는데, 막상 이진탐색 문제라는게 분류에 적혀있어도 어떻게 적용해야 할 지 막막하다.
결론부터 말하면 다음과 같다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 10816 : 숫자 카드 2</title>
      <link>https://parkjoungwan.github.io/blog/nojam10816/</link>
      <pubDate>Tue, 23 Mar 2021 21:00:00 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam10816/</guid>
      <description>문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.
예제 10 6 3 2 10 10 10 -10 -10 7 3 8 10 9 -5 2 3 4 5 -10  출력 3 0 0 1 2 0 0 2  풀이 이진탐색 문제이다. M개의 숫자가 N개의 카드 풀안에 존재하는지 찾는 방법을 이진탐색을 이용한다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 10815 : 숫자 카드</title>
      <link>https://parkjoungwan.github.io/blog/nojam10815/</link>
      <pubDate>Tue, 23 Mar 2021 14:42:45 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam10815/</guid>
      <description>문제 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
예제 5 6 3 2 10 -10 8 10 9 -5 2 3 4 5 -10  출력 1 0 0 1 1 0 0 1  풀이 이진탐색 문제이다. M개의 숫자가 N개의 카드 풀안에 존재하는지 찾는 방법을 이진탐색을 이용한다. 이진탐색의 핵심은</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 6359 : 만취한 상범</title>
      <link>https://parkjoungwan.github.io/blog/nojam6359/</link>
      <pubDate>Wed, 17 Mar 2021 16:59:05 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam6359/</guid>
      <description>문제 테스트 케이스 T, 정수 N을 입력받는다.
N개의 감옥은 모두 잠겨있다.
그리고 1부터 N이 될 때까지 1씩 증가하며,
해당 값의 곱셈 값의 감옥문을 잠겼으면 열고 열렸으면 잠근다.
열려있는 감옥의 수를 구하라.
예제 2 5 100  출력 2 10  풀이 단순 구현문제로 볼 수 있는 문제다.
모든 감옥을 배열로 구현하고 위에서 시키는대로 열고 닫아도 시간 초과가 나지않는 걸로 보인다.
구현하다가 알게된 해법은 다음과 같다.
&amp;ldquo;N과 같거나 작은 제곱수의 감옥의 문이 열려있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2193 : 이친수</title>
      <link>https://parkjoungwan.github.io/blog/nojam2193/</link>
      <pubDate>Wed, 17 Mar 2021 16:51:45 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2193/</guid>
      <description>문제 간략하게 나타내면 다음과 같다.
이친수란, 다음의 규칙을 만족하는 이진수이다.
 이친수는 0으로 시작하지 않는다. 이친수는 1이 연속 두번으로 올 수 없다.  입력값 N이 주어졌을때, N자리 수의 이친수 개수를 구하자.
예제 3  출력 2  풀이 이 문제도 이전과 같은 DP 다이나믹 프로그래밍 문제이다.
내가 사용한 해법은 요약하면 다음과 같다.
&amp;ldquo;마지막 숫자가 0으로 끝나는 이친수는 0과 1을 붙일 수 있고, 마지막 숫자가 1로 끝나는 이친수는 0을 붙일 수 있다.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 2156 : 포도주 시식</title>
      <link>https://parkjoungwan.github.io/blog/nojam2156/</link>
      <pubDate>Wed, 17 Mar 2021 13:51:30 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam2156/</guid>
      <description>문제 간략화 하자면 다음과 같다.
 1번째 부터 n 까지의 숫자를 더할 것이다. 연속된 숫자는 2개까지 더할 수 있다. 위 규칙을 지키면서 만들 수 있는 최대의 숫자를 만들어라.  예제 6 6 10 13 9 8 1  출력 33  풀이 이 문제는 이전과 같은 DP 다이나믹 프로그래밍의 일종이다.
내가 사용한 해법을 최대한 요약하면 다음과 같다.
&amp;ldquo;각 최대값은 이전 최대값에 다음 수를 더해서 구할 수 있다. 4개 씩 끊어서 생각하자.</description>
    </item>
    
    <item>
      <title>[Algorithm, C&#43;&#43;] 백준 1912 : 연속합</title>
      <link>https://parkjoungwan.github.io/blog/nojam1912/</link>
      <pubDate>Sun, 14 Mar 2021 23:52:10 +0900</pubDate>
      
      <guid>https://parkjoungwan.github.io/blog/nojam1912/</guid>
      <description>문제 n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
입력 조건 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다.</description>
    </item>
    
  </channel>
</rss>
